import logging
import ifcopenshell
import ifcopenshell.api
import ifcopenshell.util
from ifcopenshell.util import date as ifc_date # Renamed to avoid conflict
from ifcopenshell.util import element as ifc_element # Renamed for clarity
from ifcopenshell.util import placement as ifc_placement # Renamed for clarity
from ifcopenshell.util import unit as ifc_unit # Renamed for clarity
from ifcopenshell.util import geolocation as ifc_geolocation # Added import for geolocation
import uuid
import time
import datetime # Added import for datetime module
from typing import Any, Optional, Dict, List, Tuple
import os
import numpy as np

logger = logging.getLogger(__name__) # Added logger

class IFCmodel:
    # def __init__(self, project_name, output_file): # Old constructor
    def __init__(self, output_file: str, config_params: Dict[str, Any]):
        """
        Initializes the IFC model with settings from config_params.
        Args:
            output_file: Path to save the generated IFC file.
            config_params: Dictionary containing IFC settings, typically from config_params["ifc"].
        """
        ifc_settings = config_params.get("ifc", {})

        self.config_params = config_params

        self.output_file = output_file
        self.project_name = ifc_settings.get("project_name", "Default Project")
        self.project_description = ifc_settings.get("project_description", "An IFC model generated by Cloud2BIM")
        self.long_project_name = ifc_settings.get("ifc_project_long_name", self.project_name) # Fallback to project_name
        self.construction_phase = ifc_settings.get("ifc_building_phase", "CONSTRUCTION")
        self.author_name = ifc_settings.get("ifc_author_name", "Cloud2BIM User")
        self.author_surname = ifc_settings.get("ifc_author_surname", "") # Optional
        self.author_organization = ifc_settings.get("ifc_author_organization", "Cloud2BIM")
        self.version = ifc_settings.get("ifc_project_version", "1.0")
        
        # Site information - ensure these are present or have defaults
        self.site_latitude = tuple(ifc_settings.get("ifc_site_latitude", [0,0,0,0])) # Example: [DD, MM, SS, uS]
        self.site_longitude = tuple(ifc_settings.get("ifc_site_longitude", [0,0,0,0]))
        self.site_elevation = ifc_settings.get("ifc_site_elevation", 0.0)
        
        self.building_name = ifc_settings.get("ifc_building_name", "Default Building")
        self.building_type = ifc_settings.get("building_type", "NOTDEFINED") # From sample_config

        self.material_for_objects = ifc_settings.get("material_for_objects", "DefaultMaterial")
        self.export_materials = ifc_settings.get("export_materials", True) # From sample_config

        # Create a new IFC file and add header data
        self.ifc_file = ifcopenshell.file()
        self.ifc_file.header.file_description.description = ('ViewDefinition [DesignTransferView_V1.0]',)
        self.ifc_file.header.file_name.name = self.output_file
        self.ifc_file.header.file_name.time_stamp = ifcopenshell.util.date.datetime2ifc(datetime.datetime.now(), "IfcDateTime")
        # Authors can be a list of strings
        authors = [f"{self.author_name} {self.author_surname}".strip()] if self.author_surname else [self.author_name]
        self.ifc_file.header.file_name.author = tuple(authors)
        self.ifc_file.header.file_name.organization = (self.author_organization,)
        self.ifc_file.header.file_name.preprocessor_version = 'IfcOpenShell {0}'.format(ifcopenshell.version)
        self.ifc_file.header.file_name.originating_system = 'CTU in Prague - Cloud2BIM - 1.1' # Consider making this configurable
        self.ifc_file.header.file_name.authorization = 'None' # Consider making this configurable

        # Setup basic IFC structure (Project, Site, Building, Storey)
        self.owner_history = self.create_owner_history()
        self.unit_assignment = self.create_unit_assignment()
        self.geom_rep_context, self.geom_rep_sub_context = self.create_geometric_representation_context()
        
        self.project = self.create_project()
        self.site = self.create_site(self.project)
        self.building = self.create_building(self.site)
        # For simplicity, create one default building storey. More complex scenarios might need multiple storeys.
        self.building_storey = self.create_building_storey(self.building, elevation=0.0, name="Ground Floor")

        logger.info(f"IFC model initialized for project '{self.project_name}', output to '{self.output_file}'")

    @staticmethod
    def generate_guid():
        return ifcopenshell.guid.new()
    
    def create_owner_history(self):
        """Creates IfcOwnerHistory."""
        person = self.ifc_file.create_entity(
            "IfcPerson",
            GivenName=self.author_name,
            FamilyName=self.author_surname if self.author_surname else None # Optional
        )
        organization = self.ifc_file.create_entity(
            "IfcOrganization",
            Name=self.author_organization
        )
        person_and_org = self.ifc_file.create_entity(
            "IfcPersonAndOrganization",
            ThePerson=person,
            TheOrganization=organization
        )
        application = self.ifc_file.create_entity(
            "IfcApplication",
            ApplicationDeveloper=organization, # Assuming developer is the same org
            Version=self.version, # Project version
            ApplicationFullName="Cloud2BIM Conversion Service", # Tool name
            ApplicationIdentifier="Cloud2BIM_v1"
        )
        owner_history = self.ifc_file.create_entity(
            "IfcOwnerHistory",
            OwningUser=person_and_org,
            OwningApplication=application,
            ChangeAction="ADDED",
            CreationDate=int(datetime.datetime.now().timestamp())
        )
        return owner_history

    def create_local_placement(self, coordinates: Tuple[float, float, float], axis: Optional[Any]=None, ref_direction: Optional[Any]=None, relative_to: Optional[Any]=None):
        """
        Creates an IfcLocalPlacement using a generic IfcAxis2Placement3D.
        :param coordinates: Tuple (x, y, z) for the location.
        :param axis: Optional IfcDirection entity for the axis.
        :param ref_direction: Optional IfcDirection entity for the reference direction.
        :param relative_to: Optional IfcLocalPlacement to relate to.
        """
        axis_placement = self.ifc_file.create_entity(
            "IfcAxis2Placement3D",
            Location=self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=coordinates),
            Axis=axis,
            RefDirection=ref_direction
        )
        if relative_to:
            return self.ifc_file.create_entity("IfcLocalPlacement", RelativePlacement=axis_placement, PlacementRelTo=relative_to)
        else:
            return self.ifc_file.create_entity("IfcLocalPlacement", RelativePlacement=axis_placement)

    def create_extruded_solid(self, swept_area: Any, position: Any, extrusion_direction: Any, depth: float):
        """
        Creates an IfcExtrudedAreaSolid entity.
        :param swept_area: The area profile to be extruded.
        :param position: The placement for the extrusion.
        :param extrusion_direction: The extrusion direction (IfcDirection).
        :param depth: The extrusion depth.
        """
        return self.ifc_file.create_entity(
            "IfcExtrudedAreaSolid",
            SweptArea=swept_area,
            Position=position,
            ExtrudedDirection=extrusion_direction,
            Depth=depth
        )

    def create_shape_representation(self, context: Any, rep_id: str, rep_type: str, items: List[Any]):
        """
        Wraps geometry items into an IfcShapeRepresentation.
        :param context: The geometric representation context.
        :param rep_id: Representation Identifier (e.g., "Body", "Axis").
        :param rep_type: Representation type (e.g., "SweptSolid").
        :param items: List of geometry items.
        """
        return self.ifc_file.create_entity(
            "IfcShapeRepresentation",
            ContextOfItems=context,
            RepresentationIdentifier=rep_id,
            RepresentationType=rep_type,
            Items=items
        )

    def create_rel_defines_by_type(self, related_object: Any, relating_type: Any, description: Optional[str]=None, name: Optional[str]=None):
        """
        Creates an IfcRelDefinesByType entity
        :param related_object: The IFC object instance (e.g., wall, column, window).
        :param relating_type: The IFC type entity associated with the object (e.g., WallType, ColumnType).
        :param description: A textual description of the relationship.
        :param name: A name for the relationship.
        """
        return self.ifc_file.create_entity(
            "IfcRelDefinesByType",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=name,
            Description=description,
            RelatedObjects=[related_object],
            RelatingType=relating_type
        )

    # def define_author_information(self, author_name, author_organization): # Covered by __init__
    #     self.author_name = author_name
    #     self.author_organization = author_organization
    #     self.ifc_file.header.file_name.author = (self.author_name,)
    #     self.ifc_file.header.file_name.organization = (self.author_organization,)

    def create_unit_assignment(self) -> Any:
        """Creates IfcUnitAssignment with metric units."""
        length_unit = self.ifc_file.create_entity("IfcSIUnit", UnitType="LENGTHUNIT", Name="METRE")
        area_unit = self.ifc_file.create_entity("IfcSIUnit", UnitType="AREAUNIT", Name="SQUARE_METRE")
        volume_unit = self.ifc_file.create_entity("IfcSIUnit", UnitType="VOLUMEUNIT", Name="CUBIC_METRE")
        plane_angle_unit = self.ifc_file.create_entity("IfcSIUnit", UnitType="PLANEANGLEUNIT", Name="RADIAN")
        # solid_angle_unit = self.ifc_file.create_entity("IfcSIUnit", UnitType="SOLIDANGLEUNIT", Name="STERADIAN") # Less common for basic models
        unit_assignment = self.ifc_file.create_entity(
            "IfcUnitAssignment",
            Units=[length_unit, area_unit, volume_unit, plane_angle_unit]
        )
        return unit_assignment
    
    def create_geometric_representation_context(self) -> Tuple[Any, Any]:
        """Creates IfcGeometricRepresentationContext and a sub-context for 'Body' geometry."""
        context = self.ifc_file.create_entity(
            "IfcGeometricRepresentationContext",
            ContextIdentifier="Model",
            ContextType="Model",
            CoordinateSpaceDimension=3,
            Precision=1.e-5, # A common precision value
            WorldCoordinateSystem=self.create_local_placement(coordinates=(0., 0., 0.)), # Origin
            TrueNorth=None # Can be set if known
        )
        sub_context = self.ifc_file.create_entity(
            "IfcGeometricRepresentationSubContext",
            ContextIdentifier="Body",
            ContextType="Model",
            ParentContext=context,
            TargetView="MODEL_VIEW" # Common target view
        )
        return context, sub_context

    def create_project(self) -> Any:
        """Creates the IfcProject entity."""
        project = self.ifc_file.create_entity(
            "IfcProject",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=self.project_name,
            Description=self.project_description,
            ObjectType=None, # Or a specific project type if applicable
            LongName=self.long_project_name,
            Phase=self.construction_phase,
            RepresentationContexts=[self.geom_rep_context],
            UnitsInContext=self.unit_assignment
        )
        return project

    def create_site(self, project: Any) -> Any:
        """Creates the IfcSite entity and relates it to the project."""
        site_placement = self.create_local_placement(coordinates=(0., 0., 0.))
        
        ref_latitude_dms = None
        if self.site_latitude is not None:
            try:
                # Assuming self.site_latitude is in decimal degrees
                # dd2dms returns (degrees, minutes, seconds, optional_milliseconds)
                # IfcSite expects a list of 3 or 4 integers: [degrees, minutes, seconds, (optional) millionth_seconds]
                d, m, s, ms = ifc_geolocation.dd2dms(float(self.site_latitude), use_ms=True)
                ref_latitude_dms = [int(d), int(m), int(s), int(ms * 1_000_000)] # Convert ms to millionth_seconds
            except Exception as e:
                logging.warning(f"Could not convert site_latitude {self.site_latitude} to DMS: {e}")
                ref_latitude_dms = None

        ref_longitude_dms = None
        if self.site_longitude is not None:
            try:
                # Assuming self.site_longitude is in decimal degrees
                d, m, s, ms = ifc_geolocation.dd2dms(float(self.site_longitude), use_ms=True)
                ref_longitude_dms = [int(d), int(m), int(s), int(ms * 1_000_000)] # Convert ms to millionth_seconds
            except Exception as e:
                logging.warning(f"Could not convert site_longitude {self.site_longitude} to DMS: {e}")
                ref_longitude_dms = None

        site = self.ifc_file.create_entity(
            "IfcSite",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=self.config_params.get("Site_Parameters", {}).get("site_name", "Default Site"),
            Description=self.config_params.get("Site_Parameters", {}).get("site_description", "Default Site Description"),
            ObjectPlacement=site_placement,
            CompositionType="ELEMENT",
            RefLatitude=ref_latitude_dms,
            RefLongitude=ref_longitude_dms,
            RefElevation=self.site_elevation if self.site_elevation is not None else None,
            # LandTitleNumber=self.config_params.get("Site_Parameters", {}).get("land_title_number"), # Optional
            # SiteAddress=self.config_params.get("Site_Parameters", {}).get("site_address") # Optional
        )
        self.ifc_file.create_entity(
            "IfcRelAggregates",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            RelatingObject=project,
            RelatedObjects=[site]
        )
        return site

    def create_building(self, site: Any) -> Any:
        """Creates the IfcBuilding entity and relates it to the site."""
        building_placement = self.create_local_placement(coordinates=(0., 0., 0.), relative_to=site.ObjectPlacement)
        building = self.ifc_file.create_entity(
            "IfcBuilding",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=self.building_name, # From config
            ObjectPlacement=building_placement,
            CompositionType="ELEMENT",
            BuildingAddress=None # Could be added if available
        )
        self.ifc_file.create_entity(
            "IfcRelAggregates",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            RelatingObject=site,
            RelatedObjects=[building]
        )
        return building

    def create_building_storey(self, building: Any, elevation: float, name: str = "Default Storey") -> Any:
        """Creates an IfcBuildingStorey and relates it to the building."""
        storey_placement = self.create_local_placement(coordinates=(0., 0., elevation), relative_to=building.ObjectPlacement)
        storey = self.ifc_file.create_entity(
            "IfcBuildingStorey",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=name,
            ObjectPlacement=storey_placement,
            CompositionType="ELEMENT",
            Elevation=elevation
        )
        self.ifc_file.create_entity(
            "IfcRelAggregates",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            RelatingObject=building,
            RelatedObjects=[storey]
        )
        return storey

    def create_material_with_color(self, name: str, rgb_values: Tuple[float, float, float], transparency: float = 0.0) -> Tuple[Any, Any]:
        """
        Create a complete material with color in one function call

        Args:
            name: Name of the material
            rgb_values: Tuple/list of (red, green, blue) values (0-1)
            transparency: Transparency value (0-1)

        Returns:
            tuple: (material, material_definition_representation)
        """
        # Create color and style objects
        color_rgb = self.ifc_file.create_entity(
            "IfcColourRgb",
            Name=None,
            Red=rgb_values[0],
            Green=rgb_values[1],
            Blue=rgb_values[2]
        )

        # Create surface style rendering
        surface_style_rendering = self.ifc_file.create_entity(
            "IfcSurfaceStyleRendering",
            SurfaceColour=color_rgb,
            Transparency=transparency,
            DiffuseColour=self.ifc_file.createIfcNormalisedRatioMeasure(0.4), # Example diffuse
            TransmissionColour=None,
            DiffuseTransmissionColour=None,
            ReflectionColour=None,
            SpecularColour=None,
            SpecularHighlight=None,
            ReflectanceMethod="NOTDEFINED"
        )

        # Create surface style
        surface_style = self.ifc_file.create_entity(
            "IfcSurfaceStyle",
            Name=name, # Material name as style name
            Side="BOTH",
            Styles=[surface_style_rendering]
        )

        # Create presentation style assignment
        # This is typically not directly used for IfcMaterial itself but for IfcStyledItem
        # presentation_style_assignment = self.ifc_file.create_entity(
        #     "IfcPresentationStyleAssignment",
        #     Styles=[surface_style]
        # )

        # Create material
        material = self.ifc_file.create_entity(
            "IfcMaterial",
            Name=name,
            Description=f"Color {rgb_values}, Transparency {transparency}"
        )
        
        # Associate style with material using IfcMaterialDefinitionRepresentation
        # This is how materials get their visual appearance in some viewers.
        # Note: IfcStyledItem is used to link a style to a specific representation item (geometry),
        # not directly to the IfcMaterial in this way for its definition.
        # Instead, IfcMaterial can have associated IfcSurfaceStyle through IfcMaterialDefinitionRepresentation.

        # Create IfcMaterialDefinitionRepresentation
        # This links the material to its visual style for representation purposes.
        # However, the direct assignment of styles to geometry items (via IfcStyledItem)
        # is more common for controlling appearance of specific elements.
        # For now, we create the material and the style. The association happens when applying to elements.

        # The IfcStyledItem and IfcStyledRepresentation part from the original code seems
        # more related to applying a style to a specific geometric item rather than defining
        # the material's inherent appearance. We will create the material and style here,
        # and apply them to elements (e.g., walls, slabs) later.

        # For now, just return the material and the surface style. The linking will be done per element.
        logger.debug(f"Created material '{name}' with RGB {rgb_values} and style.")
        return material, surface_style # Return both, style will be used in styled items

    def add_wall(self, wall_data: Dict[str, Any], storey: Any):
        """
        Adds a wall to the IFC model based on detected wall_data.
        wall_data should contain geometry (e.g., plane_equation, bounding_box, length, height, thickness)
        and point indices.
        """
        if not wall_data: # or check for essential keys
            logger.warning("add_wall called with empty or invalid wall_data.")
            return None

        logger.info(f"Adding wall: {wall_data.get('id', 'N/A')}")

        # Extract parameters from wall_data - these are examples and need to match detect_walls output
        # For a simple extruded rectangle:
        # - A start point (e.g., one corner of the wall on the floor)
        # - Length (along its primary axis)
        # - Height
        # - Thickness
        # - Orientation (direction vector of its length)

        # Placeholder: Assume wall_data provides enough info for a simple box or extrusion
        # Example: wall_data might have 'center_point', 'length_vector', 'height', 'thickness'
        # Or, 'footprint_polygon_2d', 'extrusion_height', 'base_elevation'

        # This is a highly simplified representation of a wall as an extruded rectangle.
        # Real wall geometry from point clouds is much more complex.
        
        # Example: Create a simple rectangular profile for extrusion
        # Assume wall_data provides: 
        #   'origin': [x,y,z] of a corner
        #   'length': length of the wall
        #   'thickness': thickness of the wall
        #   'height': height of the wall
        #   'axis_direction': [dx, dy] unit vector for wall length direction in XY plane
        #   'extrusion_direction': [0,0,1] for vertical extrusion

        # Simplified example - this needs to be derived from actual wall_data structure
        wall_length = wall_data.get("length", 2.0) # Default if not in wall_data
        wall_thickness = wall_data.get("thickness", 0.2)
        wall_height = wall_data.get("height", 2.5)
        # Assume origin is at [0,0,0] relative to storey for this example
        # A more robust placement would use wall_data["bounding_box"] or similar
        object_placement = self.create_local_placement(coordinates=(0.,0.,0.), relative_to=storey.ObjectPlacement)

        # Create a rectangular profile for the wall's cross-section (thickness x height)
        # This profile is then extruded by wall_length.
        # Or, create a footprint (length x thickness) and extrude by height.
        # Let's use footprint (length x thickness) extruded by height.

        profile_points = [
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., 0.)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(wall_length, 0.)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(wall_length, wall_thickness)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., wall_thickness)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., 0.)) # Close the loop
        ]
        polyline = self.ifc_file.create_entity("IfcPolyline", Points=profile_points)
        swept_area_profile = self.ifc_file.create_entity(
            "IfcArbitraryClosedProfileDef",
            ProfileType="AREA",
            OuterCurve=polyline
        )

        # Extrusion parameters
        extrusion_placement = self.create_local_placement(coordinates=(0.,0.,0.)) # Relative to object_placement
        extrusion_direction_vec = self.ifc_file.create_entity("IfcDirection", DirectionRatios=(0., 0., 1.))
        
        solid_geometry = self.create_extruded_solid(
            swept_area=swept_area_profile,
            position=extrusion_placement,
            extrusion_direction=extrusion_direction_vec,
            depth=wall_height
        )

        shape_representation = self.create_shape_representation(
            context=self.geom_rep_sub_context, # Use the 'Body' sub-context
            rep_id="Body",
            rep_type="SweptSolid",
            items=[solid_geometry]
        )

        # Create IfcWallStandardCase or IfcWall
        # IfcWallStandardCase is simpler if you have a common type
        # IfcWall allows more flexibility
        wall = self.ifc_file.create_entity(
            "IfcWall", # Or IfcWallStandardCase
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=wall_data.get("id", "Wall"), # Use an ID from detection if available
            Description=wall_data.get("description", "A detected wall"),
            ObjectPlacement=object_placement,
            Representation=self.ifc_file.create_entity("IfcProductDefinitionShape", Representations=[shape_representation]),
            Tag=wall_data.get("tag", None) # Optional tag
        )

        # Relate wall to storey
        self.ifc_file.create_entity(
            "IfcRelContainedInSpatialStructure",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            RelatingStructure=storey,
            RelatedElements=[wall]
        )

        # Apply material if specified
        if self.export_materials and self.material_for_objects:
            # Assuming a generic material for all objects for now
            # In a real scenario, material might come from wall_data or a mapping
            material_name = self.material_for_objects
            # Example color (light grey), make this configurable or based on material_name
            material_rgb = (0.8, 0.8, 0.8) 
            
            material, surface_style = self.create_material_with_color(material_name, material_rgb)
            
            # Create IfcMaterialLayer for IfcWallStandardCase (if using types)
            # Or apply style directly for IfcWall
            
            # Apply style to the wall's shape representation
            styled_item = self.ifc_file.create_entity(
                "IfcStyledItem",
                Item=solid_geometry, # Apply to the geometric item
                Styles=[self.ifc_file.create_entity("IfcPresentationStyleAssignment", Styles=[surface_style])],
                Name=None
            )
            # Replace the original shape representation with one that includes the styled item
            # This is a bit tricky. Often, styles are part of the shape representation items.
            # For simplicity, we might need to adjust how shape_representation is created if styling is complex.
            # One common way: IfcShapeRepresentation.Items can include IfcStyledItem.
            # Let's try to modify the existing shape_representation if possible, or create a new one with style.

            # Option 1: Add styled_item to existing representation (if it was just the solid)
            # This assumes the representation can hold multiple items, one of which is styled.
            # However, IfcStyledItem itself wraps an Item. So the solid_geometry should be the Item in IfcStyledItem.
            
            # Create a new shape representation that includes the styled item
            # The styled_item already refers to solid_geometry
            styled_shape_representation = self.create_shape_representation(
                context=self.geom_rep_sub_context,
                rep_id="Body",
                rep_type="SweptSolid", # Or a more generic type if it includes styling
                items=[styled_item] # The styled_item now wraps the solid_geometry
            )
            wall.Representation.Representations = [styled_shape_representation]

            # Associate the material with the wall (semantically)
            self.ifc_file.create_entity(
                "IfcRelAssociatesMaterial",
                GlobalId=self.generate_guid(),
                OwnerHistory=self.owner_history,
                RelatedObjects=[wall],
                RelatingMaterial=material
            )

        logger.info(f"Wall '{wall.Name}' added to IFC model.")
        return wall

    def add_slab(self, slab_data: Dict[str, Any], storey: Any):
        """
        Adds a slab to the IFC model based on detected slab_data.
        slab_data should contain geometry (e.g., polygon_footprint, z_level, thickness)
        and point indices.
        """
        if not slab_data:
            logger.warning("add_slab called with empty or invalid slab_data.")
            return None
        
        logger.info(f"Adding slab: {slab_data.get('id', 'N/A')}")

        # Extract parameters - this is highly dependent on detect_slabs output
        # Example: slab_data might have 'footprint_polygon_2d', 'base_z', 'thickness'
        
        # Simplified example: Assume a rectangular slab
        slab_length = slab_data.get("length", 3.0) # Example, from footprint
        slab_width = slab_data.get("width", 2.0)   # Example, from footprint
        slab_thickness = slab_data.get("thickness", 0.3)
        # Assume origin is at [0,0,base_z] relative to storey for this example
        # A more robust placement would use slab_data["bounding_box"] or polygon points
        base_z = slab_data.get("z_level", 0.0) # Relative to storey elevation or absolute?
                                            # Assuming relative to storey for placement.
        object_placement = self.create_local_placement(coordinates=(0.,0.,base_z), relative_to=storey.ObjectPlacement)

        # Create a rectangular profile for the slab's footprint (length x width)
        profile_points = [
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., 0.)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(slab_length, 0.)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(slab_length, slab_width)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., slab_width)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., 0.)) # Close loop
        ]
        polyline = self.ifc_file.create_entity("IfcPolyline", Points=profile_points)
        swept_area_profile = self.ifc_file.create_entity(
            "IfcArbitraryClosedProfileDef",
            ProfileType="AREA",
            OuterCurve=polyline
        )

        # Extrusion parameters (extrude by thickness)
        extrusion_placement = self.create_local_placement(coordinates=(0.,0.,0.)) # Relative to object_placement of slab
        extrusion_direction_vec = self.ifc_file.create_entity("IfcDirection", DirectionRatios=(0., 0., 1.))
        
        solid_geometry = self.create_extruded_solid(
            swept_area=swept_area_profile,
            position=extrusion_placement,
            extrusion_direction=extrusion_direction_vec,
            depth=slab_thickness
        )

        shape_representation = self.create_shape_representation(
            context=self.geom_rep_sub_context,
            rep_id="Body",
            rep_type="SweptSolid",
            items=[solid_geometry]
        )

        slab = self.ifc_file.create_entity(
            "IfcSlab", 
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=slab_data.get("id", "Slab"),
            Description=slab_data.get("description", "A detected slab"),
            ObjectPlacement=object_placement,
            Representation=self.ifc_file.create_entity("IfcProductDefinitionShape", Representations=[shape_representation]),
            Tag=slab_data.get("tag", None),
            PredefinedType="FLOOR" # Or ROOF, BASESLAB etc. based on context or config
        )

        self.ifc_file.create_entity(
            "IfcRelContainedInSpatialStructure",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            RelatingStructure=storey,
            RelatedElements=[slab]
        )

        # Apply material (similar to wall)
        if self.export_materials and self.material_for_objects:
            material_name = self.material_for_objects
            material_rgb = (0.7, 0.7, 0.7) # Slightly different grey for slabs
            material, surface_style = self.create_material_with_color(material_name + "_Slab", material_rgb) # Unique name for style
            
            styled_item = self.ifc_file.create_entity(
                "IfcStyledItem",
                Item=solid_geometry,
                Styles=[self.ifc_file.create_entity("IfcPresentationStyleAssignment", Styles=[surface_style])],
                Name=None
            )
            styled_shape_representation = self.create_shape_representation(
                context=self.geom_rep_sub_context,
                rep_id="Body",
                rep_type="SweptSolid",
                items=[styled_item]
            )
            slab.Representation.Representations = [styled_shape_representation]

            self.ifc_file.create_entity(
                "IfcRelAssociatesMaterial",
                GlobalId=self.generate_guid(),
                OwnerHistory=self.owner_history,
                RelatedObjects=[slab],
                RelatingMaterial=material
            )

        logger.info(f"Slab '{slab.Name}' added to IFC model.")
        return slab

    def add_slabs(self, slabs_data: List[Dict[str, Any]], storey: Any):
        """
        Adds multiple slabs to the IFC model based on detection results.
        
        Args:
            slabs_data: List of slab data dictionaries from detect_slabs function
            storey: The IfcBuildingStorey to which the slabs will be assigned
        
        Returns:
            List of created slab entities
        """
        logger.info(f"Adding {len(slabs_data)} slabs to IFC model")
        slab_entities = []
        
        for slab_data in slabs_data:
            # Extract necessary data from the slab dictionary
            slab_id = slab_data.get("id", f"Slab_{len(slab_entities)+1}")
            
            # Extract points from cluster points for creating polygon
            cluster_points = slab_data.get("cluster_pcd_points", [])
            if not cluster_points:
                logger.warning(f"Slab {slab_id} has no points. Skipping.")
                continue
            
            # Project points to XY plane and extract boundary
            points_xy = np.array(cluster_points)[:, :2]
            
            # Get the plane equation and normal
            plane_eq = slab_data.get("plane_equation", [0, 0, 1, 0])
            normal = slab_data.get("normal", [0, 0, 1])
            
            # Get thickness from config or default
            slab_thickness = self.ifc_settings.get("slab", {}).get("thickness", 0.3)
            
            # Calculate the z position from plane equation
            # For a plane ax+by+cz+d=0, z = (-d-ax-by)/c if c != 0
            if abs(normal[2]) > 0.01:  # Ensure we don't divide by zero
                center = slab_data.get("center_aabb", [0, 0, 0])
                z_level = center[2] - slab_thickness/2  # Place slab so midpoint is at center
            else:
                z_level = 0  # Default if we can't determine

            # For simplified geometry, use the extent from the AABB
            extent = slab_data.get("extent_aabb", [3.0, 2.0, 0.3])
            
            # Update slab data with needed parameters for add_slab
            slab_params = {
                "id": slab_id,
                "length": extent[0],
                "width": extent[1],
                "thickness": slab_thickness,
                "z_level": z_level,
                "description": f"Detected slab from point cloud",
                "tag": slab_id
            }
            
            # Call add_slab to create the actual IFC entity
            slab_entity = self.add_slab(slab_params, storey)
            if slab_entity:
                slab_entities.append(slab_entity)
        
        logger.info(f"Successfully added {len(slab_entities)} slabs to IFC model")
        return slab_entities

    def add_opening(self, opening_data: Dict[str, Any], host_element: Any):
        """
        Adds an opening to a host element (e.g., a wall or slab).
        opening_data should contain geometry (e.g., bounding_box_3d, width, height, depth).
        host_element is the IfcWall or IfcSlab entity that contains the opening.
        """
        if not opening_data or not host_element:
            logger.warning("add_opening called with invalid data or no host element.")
            return None

        logger.info(f"Adding opening: {opening_data.get('id', 'N/A')} to host {host_element.Name}")

        # Extract opening parameters - highly dependent on detect_openings output
        # Example: 'bounding_box_3d' relative to the host element's coordinate system, or absolute.
        # 'width', 'height', 'depth' (usually thickness of host)

        # Simplified example: Assume opening_data provides dimensions and a relative placement
        op_width = opening_data.get("width", 0.8)
        op_height = opening_data.get("height", 2.0)
        op_depth = opening_data.get("depth", 0.2) # Should match host thickness ideally
        
        # Placement of the opening relative to the host element's placement
        # This is crucial and complex. For simplicity, assume it's at (x,y,z) in host's local coords.
        # Example: relative_op_coords = opening_data.get("relative_origin", (0.5, 0.0, 0.5)) # (x along wall, 0 in thickness dir, z from base)
        relative_op_coords = (0.5, 0.0, 0.5) # Placeholder

        opening_placement = self.create_local_placement(
            coordinates=relative_op_coords, 
            relative_to=host_element.ObjectPlacement
        )

        # Create a box shape for the opening void
        # Profile for extrusion (width x height)
        profile_points = [
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., 0.)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(op_width, 0.)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(op_width, op_height)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., op_height)),
            self.ifc_file.create_entity("IfcCartesianPoint", Coordinates=(0., 0.))
        ]
        polyline = self.ifc_file.create_entity("IfcPolyline", Points=profile_points)
        swept_area_profile = self.ifc_file.create_entity(
            "IfcArbitraryClosedProfileDef",
            ProfileType="AREA",
            OuterCurve=polyline
        )

        # Extrusion for depth
        extrusion_placement = self.create_local_placement(coordinates=(0.,0.,0.))
        # Extrusion direction depends on host. For a Z-up wall, extrusion is along Y (thickness).
        # This needs to be determined from host geometry or opening_data.
        # Assuming extrusion is along the local Y axis of the opening placement for its depth.
        extrusion_direction_vec = self.ifc_file.create_entity("IfcDirection", DirectionRatios=(0., 1., 0.)) # Example
        
        opening_solid = self.create_extruded_solid(
            swept_area=swept_area_profile,
            position=extrusion_placement,
            extrusion_direction=extrusion_direction_vec,
            depth=op_depth
        )

        opening_shape = self.create_shape_representation(
            context=self.geom_rep_sub_context,
            rep_id="Body",
            rep_type="SweptSolid", # Or CSG for subtractions
            items=[opening_solid]
        )

        # Create IfcOpeningElement
        opening_element = self.ifc_file.create_entity(
            "IfcOpeningElement",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            Name=opening_data.get("id", "Opening"),
            ObjectPlacement=opening_placement,
            Representation=self.ifc_file.create_entity("IfcProductDefinitionShape", Representations=[opening_shape]),
            PredefinedType=None # Or DOORWAY, WINDOW if known
        )

        # Create IfcRelVoidsElement to relate the opening to its host
        self.ifc_file.create_entity(
            "IfcRelVoidsElement",
            GlobalId=self.generate_guid(),
            OwnerHistory=self.owner_history,
            RelatingBuildingElement=host_element,
            RelatedOpeningElement=opening_element
        )

        # Optionally, create an IfcWindow or IfcDoor that fills the opening
        # This is a separate step and requires more details about the window/door itself.
        # For now, we just create the void.

        logger.info(f"Opening '{opening_element.Name}' added to host '{host_element.Name}'.")
        return opening_element

    def generate_ifc_file(self, detected_elements: Dict[str, List[Dict[str, Any]]]):
        """
        Populates the IFC model with detected walls, slabs, openings, etc.
        Args:
            detected_elements: A dictionary where keys are element types (e.g., "walls", "slabs")
                               and values are lists of dictionaries, each describing an element.
        """
        logger.info("Starting IFC file generation from detected elements.")

        # For simplicity, add all elements to the default building storey created in __init__
        default_storey = self.building_storey

        if "slabs" in detected_elements:
            for i, slab_data in enumerate(detected_elements["slabs"]):
                if not slab_data.get("id"):
                    slab_data["id"] = f"Slab_{i+1}"
                self.add_slab(slab_data, default_storey)
        
        if "walls" in detected_elements:
            for i, wall_data in enumerate(detected_elements["walls"]):
                if not wall_data.get("id"):
                    wall_data["id"] = f"Wall_{i+1}"
                wall_entity = self.add_wall(wall_data, default_storey)
                
                # Add openings to this wall if they are associated
                # This requires openings_data to have a reference to parent_wall_id
                if wall_entity and "openings" in detected_elements:
                    for j, opening_data in enumerate(detected_elements["openings"]):
                        # Assuming opening_data has a 'parent_wall_id' that matches wall_data['id']
                        if opening_data.get("parent_wall_id") == wall_data.get("id"):
                            if not opening_data.get("id"):
                                opening_data["id"] = f"Opening_{j+1}_In_{wall_data['id']}"
                            self.add_opening(opening_data, wall_entity)
            
            # Handle openings not directly parented (e.g., if parent_wall_id is not used)
            # This part would need refinement based on how openings are detected and associated.
            # For now, the above loop handles openings associated by a hypothetical 'parent_wall_id'.

        # TODO: Add other elements like zones, columns, beams, furniture if detected.

        try:
            self.ifc_file.write(self.output_file)
            logger.info(f"Successfully generated IFC file: {self.output_file}")
        except Exception as e:
            logger.error(f"Error writing IFC file {self.output_file}: {e}")
            raise # Re-raise the exception to be caught by the job processor

# Example usage (for testing purposes, normally called by job_processor.py)
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # Sample config_params (mimicking what job_processor would load and pass)
    sample_config = {
        "ifc": {
            "project_name": "Test Project from Main",
            "building_type": "Residential",
            "export_materials": True,
            "material_for_objects": "Concrete_C25/30",
            "ifc_author_name": "IFC Tester",
            "ifc_author_organization": "Test Corp",
            "ifc_site_latitude": [50, 5, 0, 0], # Prague
            "ifc_site_longitude": [14, 25, 0, 0],
            "ifc_site_elevation": 200.0,
            "ifc_building_name": "Test Building 01"
        }
    }

    ifc_model_generator = IFCmodel(output_file="test_model.ifc", config_params=sample_config)

    # Sample detected elements (mimicking output from cloud2entities.detect_elements)
    detected_elements_data = {
        "walls": [
            {
                "id": "Wall_Exterior_001", 
                "length": 5.0, 
                "thickness": 0.3, 
                "height": 2.8,
                "description": "Main exterior wall"
                # Add more geometric details like origin, orientation for proper placement
            },
            {
                "id": "Wall_Interior_001", 
                "length": 3.0, 
                "thickness": 0.15, 
                "height": 2.8,
                "description": "Partition wall",
                "parent_wall_id": None # Example if not tied to an opening scenario
            }
        ],
        "slabs": [
            {
                "id": "Slab_GroundFloor_001", 
                "length": 5.0, # Assuming rectangular for simplicity
                "width": 4.0,
                "thickness": 0.2,
                "z_level": 0.0, # Relative to storey
                "description": "Ground floor slab"
            }
        ],
        "openings": [
            {
                "id": "Door_001",
                "parent_wall_id": "Wall_Exterior_001", # Hosted in this wall
                "width": 0.9,
                "height": 2.1,
                "depth": 0.3, # Should match host wall thickness
                "description": "Main entrance door"
                # Add relative placement info within the wall
            }
        ]
    }

    ifc_model_generator.generate_ifc_file(detected_elements_data)
    logger.info("Test IFC generation complete. Check test_model.ifc")