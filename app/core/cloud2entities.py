from .aux_functions import load_config_and_variables # Removed log_message
from .generate_ifc import IFCmodel
from .space_generator import identify_zones # Keep direct import if it's a standalone function
# Import other necessary functions from aux_functions or other modules if they are not part of a class yet
# e.g., from .aux_functions import read_e57, e57_data_to_xyz, load_xyz_file
# e.g., from .point_cloud import identify_slabs, identify_walls, identify_openings (if these become methods of a PointCloud class later)

import numpy as np
import time
import os
import logging # Use standard logging
import json

logger = logging.getLogger(__name__)

class CloudToBimProcessor:
    """
    Processes a 3D point cloud file and converts it into an IFC BIM model.
    """
    def __init__(self, job_id: str, config_data: dict, input_dir: str, output_dir: str, point_cloud_data=None):
        """
        Initializes the CloudToBimProcessor.

        Args:
            job_id: The unique identifier for the job.
            config_data: A dictionary containing the job-specific configuration.
            input_dir: The directory containing input files for the job.
            output_dir: The directory where output files will be saved.
            point_cloud_data: Pre-loaded point cloud data (Open3D PointCloud or tuple of numpy arrays).
                             If provided, the processor won't try to load from a file.
        """
        self.job_id = job_id
        self.config = config_data
        self.input_dir = input_dir
        self.output_dir = output_dir
        self.log_filename = os.path.join(self.output_dir, f"{self.job_id}_processing.log")
        self._setup_logging()

        # Initialize state variables
        self.points_xyz = np.empty((0, 3))
        self.points_rgb = np.empty((0, 3))
        self.slabs = []
        self.walls = []
        self.all_openings = []
        self.zones = []
        self.ifc_model = None
        self.last_time = time.time()
        self.point_cloud_data = point_cloud_data

        # Default IFC file path (can be overridden by config)
        self.ifc_output_file = os.path.join(self.output_dir, f"{self.job_id}_model.ifc")
        self.point_mapping_file = os.path.join(self.output_dir, f"{self.job_id}_point_mapping.json")
        
        # Assign variables from config
        self._assign_config_variables()

    def _setup_logging(self):
        """Sets up logging for the processor instance."""
        # Using the module-level logger defined as "logger" at the top of the file.
        # If job-specific file logging is needed, it would be configured here.
        # For now, all logs from this processor will go to the handlers configured for the module logger.
        pass

    def _log(self, message: str, level: str = "info"):
        """Logs a message using the module-level logger and updates the last_time."""
        log_func = getattr(logger, level.lower(), logger.info) # Default to info if level is invalid
        log_func(f"Job {self.job_id}: {message}")
        current_time = time.time()
        elapsed = current_time - self.last_time
        logger.debug(f"Job {self.job_id}: Time since last log: {elapsed:.2f}s")
        self.last_time = current_time

    def _assign_config_variables(self):
        """Assigns configuration variables to instance attributes."""
        # Processing parameters
        self.exterior_scan = self.config.get("exterior_scan", False)
        self.dilute_pointcloud = self.config.get("dilute_pointcloud", False)
        self.dilution_factor = self.config.get("dilution_factor", 1)
        self.pc_resolution = self.config.get("preprocessing", {}).get("voxel_size", 0.05)
        self.grid_coefficient = self.config.get("detection", {}).get("grid_coefficient", 3)

        # Detection thresholds
        detection_config = self.config.get("detection", {})
        slab_config = detection_config.get("slab", {})
        wall_config = detection_config.get("wall", {})
        self.bfs_thickness = slab_config.get("thickness", 0.2)
        self.tfs_thickness = self.bfs_thickness  # Use same thickness for top and bottom slabs
        
        self.min_wall_length = wall_config.get("min_width", 0.5)
        self.min_wall_thickness = wall_config.get("min_thickness", 0.08)
        self.max_wall_thickness = wall_config.get("max_thickness", 0.5)
        self.exterior_walls_thickness = wall_config.get("thickness", 0.3)

        # IFC settings
        ifc_config = self.config.get("ifc", {})
        self.ifc_output_file = os.path.join(self.output_dir, f"{self.job_id}_model.ifc")
        self.ifc_project_name = ifc_config.get("project_name", "Cloud2BIM Project")
        self.ifc_project_long_name = ifc_config.get("project_long_name", "Generated by Cloud2BIM")
        self.ifc_project_version = ifc_config.get("version", "1.0")

        # Optional metadata
        self.ifc_author_name = ifc_config.get("author_name", "Cloud2BIM")
        self.ifc_author_surname = ifc_config.get("author_surname", "System")
        self.ifc_author_organization = ifc_config.get("organization", "Cloud2BIM")

    def _load_and_prepare_point_cloud(self):
        """Prepares point cloud data from pre-loaded data."""
        self._log(f"Starting point cloud preparation")

        if self.point_cloud_data is None:
            raise ValueError("No point cloud data provided. CloudToBimProcessor requires point_cloud_data to be passed during initialization.")
            
        # Handle different input formats
        if hasattr(self.point_cloud_data, 'points'):  # Check if it's an Open3D PointCloud
            # It's an Open3D PointCloud object
            pcd = self.point_cloud_data
            # Convert to numpy arrays
            self.points_xyz = np.asarray(pcd.points)
            if pcd.has_colors():
                self.points_rgb = np.asarray(pcd.colors)
            else:
                self.points_rgb = np.empty((len(self.points_xyz), 3))
        elif isinstance(self.point_cloud_data, tuple) and len(self.point_cloud_data) == 2:
            # It's a tuple of (points_array, colors_array)
            points_array, colors_array = self.point_cloud_data
            self.points_xyz = np.asarray(points_array)
            self.points_rgb = np.asarray(colors_array) if colors_array is not None else np.empty((len(self.points_xyz), 3))
            pcd = None  # We've already processed the arrays
        else:
            raise ValueError(f"Unsupported point_cloud_data format: {type(self.point_cloud_data)}")

        # Apply preprocessing if configured
        if hasattr(self, 'dilute_pointcloud') and self.dilute_pointcloud and hasattr(self, 'dilution_factor') and self.dilution_factor > 1:
            indices = np.arange(0, len(self.points_xyz), self.dilution_factor)
            self.points_xyz = self.points_xyz[indices]
            self.points_rgb = self.points_rgb[indices] if len(self.points_rgb) > 0 else self.points_rgb

        # Round coordinates for precision consistency
        self.points_xyz = np.round(self.points_xyz, 3)

        self._log(f"Prepared point cloud with {len(self.points_xyz)} points")
        if len(self.points_rgb) > 0:
            self._log("Color data is available")

    def _identify_slabs(self):
        """Identifies slabs from the point cloud."""
        from .aux_functions import identify_slabs # Function is defined in aux_functions.py
        self._log("Starting slab segmentation...")
        # Ensure points_rgb is passed if your identify_slabs function expects it,
        # otherwise, you might need to pass None or an empty array of the correct shape.
        # If points_rgb is not consistently populated, handle it:
        current_points_rgb = self.points_rgb if self.points_rgb.size > 0 else None

        slabs, horizontal_surface_planes = identify_slabs(
            self.points_xyz, 
            current_points_rgb, # Pass potentially None or empty RGB data
            self.bfs_thickness,
            self.tfs_thickness, 
            z_step=0.15, # Consider making this configurable
            pc_resolution=self.pc_resolution,
            plot_segmented_plane=False # Ensure plotting is off
        )
        self.slabs = slabs
        # self.horizontal_surface_planes = horizontal_surface_planes # Store if needed later
        self._log(f"Slab segmentation completed. Found {len(self.slabs)} slabs.")
        if not self.slabs:
            self._log("Warning: No slabs were identified. Subsequent steps might fail or produce empty results.")
            # Decide if this is a critical error that should stop processing
            # raise ValueError("No slabs identified, cannot proceed.")


    def _identify_walls_and_openings(self):
        """Identifies walls and openings for each storey."""
        from .point_cloud import split_pointcloud_to_storeys, identify_walls, identify_openings
        self._log("Starting wall and opening segmentation...")
        if not self.slabs:
            self._log("Skipping wall and opening segmentation as no slabs were found.")
            return

        point_cloud_storeys = split_pointcloud_to_storeys(self.points_xyz, self.slabs)
        
        wall_id_counter = 0
        processed_walls = []
        processed_openings = []

        for i, storey_pointcloud in enumerate(point_cloud_storeys):
            self._log(f"Processing storey {i+1} for walls and openings.")
            if storey_pointcloud is None or len(storey_pointcloud) == 0:
                self._log(f"Storey {i+1} has no points. Skipping.")
                continue

            # Determine z_placement and wall_height based on slab information
            # This logic is copied from the original script and might need refinement
            # based on how slabs are structured and indexed.
            # Ensure slabs list has enough elements for i and i+1 access.
            if i + 1 >= len(self.slabs): # Check if there's a slab above the current one
                 self._log(f"Warning: Not enough slab data to determine wall height for storey {i+1} based on slab {i+1}. Using estimated height or skipping.")
                 # Potentially estimate height or skip this storey for wall detection
                 # For now, let's assume a default or skip if critical info is missing
                 if i == len(point_cloud_storeys) -1: # Topmost storey
                     if self.exterior_scan:
                         z_placement = self.slabs[i]['slab_bottom_z_coord'] + self.slabs[i]['thickness']
                         # Estimate height for the topmost storey if no slab above
                         # This is a placeholder, actual logic might be more complex
                         wall_height = self.config.get("default_top_storey_height", 3.0) 
                     else:
                         z_placement = self.slabs[i]['slab_bottom_z_coord']
                         wall_height = self.slabs[i]['thickness'] + self.tfs_thickness # Approximation
                 else: # Should not happen if i+1 >= len(self.slabs)
                     continue
            else: # Normal case with slabs below and above (or top defined by last slab)
                if self.exterior_scan:
                    z_placement = self.slabs[i]['slab_bottom_z_coord'] + self.slabs[i]['thickness']
                    wall_height = self.slabs[i + 1]['slab_bottom_z_coord'] - z_placement
                else:
                    if i == 0: # First storey
                        z_placement = self.slabs[i]['slab_bottom_z_coord']
                        if i == len(point_cloud_storeys) - 1: # Single storey building
                            wall_height = self.slabs[i+1]['slab_bottom_z_coord'] - z_placement + self.tfs_thickness if (i+1 < len(self.slabs)) else self.slabs[i]['thickness'] + self.tfs_thickness
                        else: # Multi-storey, first floor
                            wall_height = self.slabs[i + 1]['slab_bottom_z_coord'] - z_placement
                    elif i == len(point_cloud_storeys) - 1: # Last storey (but not single storey)
                        z_placement = self.slabs[i]['slab_bottom_z_coord'] + self.slabs[i]['thickness']
                        wall_height = self.slabs[i + 1]['slab_bottom_z_coord'] - z_placement + self.tfs_thickness if (i+1 < len(self.slabs)) else self.slabs[i]['thickness'] + self.tfs_thickness # Approx if no slab above
                    else: # Intermediate storeys
                        z_placement = self.slabs[i]['slab_bottom_z_coord'] + slabs[i]['thickness']
                        wall_height = self.slabs[i + 1]['slab_bottom_z_coord'] - z_placement + self.slabs[i+1]['thickness']


            top_z_placement = self.slabs[i + 1]['slab_bottom_z_coord'] if i + 1 < len(self.slabs) else z_placement + wall_height

            # Ensure slab polygon is available for identify_walls
            current_slab_polygon = self.slabs[i+1]['polygon'] if i+1 < len(self.slabs) and 'polygon' in self.slabs[i+1] else None
            if current_slab_polygon is None:
                self._log(f"Warning: Slab polygon for storey {i+1} (slab index {i+1}) not found. Wall detection might be affected.")
                # Potentially skip or use a bounding box of the point cloud as a fallback
                # For now, passing None, assuming identify_walls can handle it or it's not critical for all cases

            (start_points, end_points, wall_thicknesses, wall_materials,
             translated_filtered_rotated_wall_groups, wall_labels) = identify_walls(
                storey_pointcloud, self.pc_resolution, self.min_wall_length,
                self.min_wall_thickness, self.max_wall_thickness,
                z_placement, top_z_placement, self.grid_coefficient,
                current_slab_polygon, # Pass the polygon of the slab *above* the walls being detected
                self.exterior_scan,
                exterior_walls_thickness=self.exterior_walls_thickness
            )
            self._log(f"Storey {i+1}: Identified {len(start_points)} wall segments.")

            for j in range(len(start_points)):
                wall_id_counter += 1
                wall_data = {
                    'wall_id': wall_id_counter, 
                    'storey': i + 1, 
                    'start_point': start_points[j], 
                    'end_point': end_points[j],
                    'thickness': wall_thicknesses[j], 
                    'material': wall_materials[j], 
                    'z_placement': z_placement,
                    'height': wall_height, 
                    'label': wall_labels[j]
                }
                processed_walls.append(wall_data)

                (opening_widths, opening_heights, opening_types) = identify_openings(
                    j + 1, # Wall index within the storey
                    translated_filtered_rotated_wall_groups[j],
                    wall_labels[j], self.pc_resolution, self.grid_coefficient,
                    min_opening_width=self.config.get("min_opening_width", 0.4),
                    min_opening_height=self.config.get("min_opening_height", 0.6),
                    max_opening_aspect_ratio=self.config.get("max_opening_aspect_ratio", 4),
                    door_z_max=self.config.get("door_z_max", 0.1),
                    door_min_height=self.config.get("door_min_height", 1.6),
                    opening_min_z_top=self.config.get("opening_min_z_top", 1.6),
                    plot_histograms_for_openings=False # Ensure plotting is off
                )

                for (x_start, x_end), (z_min, z_max), opening_type in zip(opening_widths, opening_heights, opening_types):
                    opening_info = {
                        "opening_wall_id": wall_id_counter, # Link to the global wall ID
                        "opening_type": opening_type,
                        "x_range_start": x_start,
                        "x_range_end": x_end,
                        "z_range_min": z_min,
                        "z_range_max": z_max
                    }
                    processed_openings.append(opening_info)
                self._log(f"Storey {i+1}, Wall {j+1} (Global ID {wall_id_counter}): Found {len(opening_widths)} openings.")
        
        self.walls = processed_walls
        self.all_openings = processed_openings
        self._log("Wall and opening segmentation completed for all storeys.")

    def _identify_zones(self):
        """Identifies zones (spaces) within each storey based on walls."""
        # from .space_generator import identify_zones # Already imported at class level
        self._log("Starting zone segmentation...")
        if not self.walls:
            self._log("Skipping zone segmentation as no walls were identified.")
            return

        # Group walls by storey for zone identification
        walls_by_storey = {}
        for wall in self.walls:
            storey_num = wall['storey']
            if storey_num not in walls_by_storey:
                walls_by_storey[storey_num] = []
            walls_by_storey[storey_num].append(wall)

        processed_zones = [] # This will be a list of dictionaries, one per storey
        for storey_num in sorted(walls_by_storey.keys()):
            storey_walls = walls_by_storey[storey_num]
            self._log(f"Identifying zones for storey {storey_num} with {len(storey_walls)} walls.")
            # The original script appends results from identify_zones directly.
            # identify_zones likely returns a dictionary of zones for *that* storey.
            zones_in_storey = identify_zones(
                storey_walls, 
                snapping_distance=self.config.get("zone_snapping_distance", 0.8),
                plot_zones=False # Ensure plotting is off
            )
            if zones_in_storey:
                # Store zones with their storey index.
                # The original `zones.append(zones_in_storey)` created a list of these dicts.
                # We need to ensure the structure matches what IFC generation expects.
                # If IFC part expects zones[idx] to be the zones for storey idx+1,
                # we need to pad `processed_zones` if some storeys have no zones.
                # For now, let's assume a direct list is fine, and IFC part handles indexing.
                 processed_zones.append(zones_in_storey) # Appends the dict for the current storey
            else:
                processed_zones.append({}) # Append an empty dict if no zones found for this storey
            self._log(f"Storey {storey_num}: Identified {len(zones_in_storey)} zones.")
        
        self.zones = processed_zones # self.zones is now a list of dicts, matching original structure
        self._log("Zone segmentation completed.")


    def _generate_ifc_model(self):
        """Generates the IFC model from the segmented entities."""
        self._log("Starting IFC model generation...")
        if not self.slabs and not self.walls:
            self._log("Skipping IFC generation as no slabs or walls were identified.")
            return

        self.ifc_model = IFCmodel(self.ifc_project_name, self.ifc_output_file)
        self.ifc_model.define_author_information(
            f"{self.ifc_author_name} {self.ifc_author_surname}", 
            self.ifc_author_organization
        )
        self.ifc_model.define_project_data(
            self.ifc_building_name, self.ifc_building_type, self.ifc_building_phase,
            self.ifc_project_long_name, self.ifc_project_version, self.ifc_author_organization,
            self.ifc_author_name, self.ifc_author_surname, self.ifc_site_latitude,
            self.ifc_site_longitude, self.ifc_site_elevation
        )

        storeys_ifc = []
        # Add Slabs and Storeys
        for idx, slab_data in enumerate(self.slabs):
            slab_position = slab_data['slab_bottom_z_coord'] + slab_data['thickness']
            ifc_storey = self.ifc_model.create_building_storey(f'Floor {slab_position:.2f}m', slab_position)
            storeys_ifc.append(ifc_storey)

            points = [[float(x), float(y)] for x, y in zip(slab_data['polygon_x_coords'], slab_data['polygon_y_coords'])]
            points_no_duplicates = [list(pt) for pt in dict.fromkeys(tuple(p) for p in points)]

            slab_entity = self.ifc_model.create_slab(
                slab_name=f'Slab {idx + 1}',
                points=points_no_duplicates,
                slab_z_position=round(slab_data['slab_bottom_z_coord'], 3),
                slab_height=round(slab_data['thickness'], 3),
                material_name=self.material_for_objects
            )
            self.ifc_model.assign_product_to_storey(slab_entity, ifc_storey)

            # Add Zones (Spaces)
            # self.zones is a list of dictionaries, where each dictionary contains zones for a storey.
            # The index idx corresponds to the current slab/storey.
            if idx < len(self.zones) and self.zones[idx]: # Check if zones exist for this storey
                ifc_space_placement = self.ifc_model.space_placement(slab_position)
                # Original code: if idx != len(slabs) - 1: # avoid creating zones on the uppermost slab
                # This condition might need re-evaluation. If uppermost slab means roof, then yes.
                # If it's the top floor slab, zones might still be relevant.
                # For now, keeping similar logic:
                if idx < len(self.slabs) -1 : # Avoid creating spaces above the last "floor" slab, assuming last slab is roof.
                                            # Or, if zones are defined for the top storey, this check might be too restrictive.
                                            # Let's assume zones[idx] corresponds to storey created from slabs[idx]
                    zone_number = 1
                    for space_name, space_data in self.zones[idx].items():
                        # Ensure space_data contains "height"
                        space_height = space_data.get("height")
                        if space_height is None:
                            self._log(f"Warning: Space {space_name} in storey {idx+1} is missing 'height'. Skipping space creation.")
                            continue
                        
                        self.ifc_model.create_space(
                            space_data,
                            ifc_space_placement,
                            (idx + 1), # Storey number
                            zone_number,
                            ifc_storey, # Assign to current IFC storey
                            space_height
                        )
                        zone_number += 1
        self._log(f"Added {len(self.slabs)} slabs and associated storeys/zones to IFC.")

        # Add Walls and Openings
        window_id_counter = 1
        door_id_counter = 1
        for wall_data in self.walls:
            start_point = tuple(float(num) for num in wall_data['start_point'])
            end_point = tuple(float(num) for num in wall_data['end_point'])
            if start_point == end_point:
                self._log(f"Skipping wall {wall_data['wall_id']} due to identical start/end points.")
                continue

            wall_thickness = wall_data['thickness']
            wall_material_name = wall_data['material'] # This should be a name for create_material_layer
            wall_z_placement = wall_data['z_placement']
            wall_height = wall_data['height']
            wall_label = wall_data['label']
            current_storey_index = wall_data['storey'] - 1 # 0-indexed for storeys_ifc list

            if current_storey_index < 0 or current_storey_index >= len(storeys_ifc):
                self._log(f"Warning: Invalid storey index {current_storey_index} for wall {wall_data['wall_id']}. Skipping wall.")
                continue
            
            ifc_storey_for_wall = storeys_ifc[current_storey_index]

            material_layer = self.ifc_model.create_material_layer(wall_thickness, wall_material_name)
            material_layer_set = self.ifc_model.create_material_layer_set([material_layer])
            material_layer_set_usage = self.ifc_model.create_material_layer_set_usage(material_layer_set, wall_thickness)
            
            wall_placement_ifc = self.ifc_model.wall_placement(wall_z_placement) # Renamed to avoid conflict
            wall_axis_placement = self.ifc_model.wall_axis_placement(start_point, end_point)
            wall_axis_representation = self.ifc_model.wall_axis_representation(wall_axis_placement)
            wall_swept_solid_representation = self.ifc_model.wall_swept_solid_representation(
                start_point, end_point, wall_height, wall_thickness
            )
            product_definition_shape = self.ifc_model.product_definition_shape(
                wall_axis_representation, wall_swept_solid_representation
            )
            
            ifc_wall = self.ifc_model.create_wall(wall_placement_ifc, product_definition_shape) # Renamed variable
            self.ifc_model.assign_material(ifc_wall, material_layer_set_usage)
            wall_type, _ = self.ifc_model.create_wall_type(ifc_wall, wall_thickness) # Unpack tuple if create_wall_type returns more
            self.ifc_model.assign_material(wall_type, material_layer_set) # Assign to type
            self.ifc_model.assign_product_to_storey(ifc_wall, ifc_storey_for_wall)
            
            wall_ext_int_parameter = self.ifc_model.create_property_single_value("IsExternal", wall_label == 'exterior')
            self.ifc_model.create_property_set(ifc_wall, [wall_ext_int_parameter], 'Pset_WallCommon') # Properties should be a list

            # Openings for this wall
            wall_openings_data = [op for op in self.all_openings if op['opening_wall_id'] == wall_data['wall_id']]

            # Create materials for openings (once per model is enough, but here for simplicity per wall)
            window_material, _ = self.ifc_model.create_material_with_color(
                'WindowMaterial', self.window_colour_rgb, transparency=0.7
            )
            door_material, _ = self.ifc_model.create_material_with_color(
                'DoorMaterial', self.door_colour_rgb
            )

            for opening_data in wall_openings_data:
                opening_type = opening_data['opening_type']
                opening_id_str = ""
                if opening_type == "window":
                    opening_id_str = f"W{window_id_counter:02d}"
                    window_id_counter += 1
                elif opening_type == "door":
                    opening_id_str = f"D{door_id_counter:02d}"
                    door_id_counter += 1
                else:
                    self._log(f"Warning: Unknown opening type '{opening_type}' for wall {wall_data['wall_id']}. Skipping opening.")
                    continue
                
                opening_width = opening_data['x_range_end'] - opening_data['x_range_start']
                opening_height = opening_data['z_range_max'] - opening_data['z_range_min']
                window_sill_height = opening_data['z_range_min'] # Name is a bit misleading, it's z_min of opening
                offset_from_start = opening_data['x_range_start']

                # Create IFC Opening Element
                opening_closed_profile = self.ifc_model.opening_closed_profile_def(float(opening_width), wall_thickness) # Use wall_thickness
                
                # opening_placement needs the wall's IfcLocalPlacement (wall_placement_ifc)
                # and the relative placement of the opening.
                # The original script's opening_placement seems to create a new local placement.
                # Let's assume it's relative to the wall's start or needs careful handling.
                # The IFCmodel methods for opening_placement and opening_extrusion need to be robust.
                
                # This is complex: opening_placement[1] was used. This implies opening_placement returns a tuple.
                # Let's assume opening_placement is correctly defined in IFCmodel to handle this.
                # It likely needs the wall's placement as a reference.
                opening_placement_tuple = self.ifc_model.opening_placement(start_point, wall_placement_ifc) # Pass wall's placement
                ifc_opening_local_placement = opening_placement_tuple[1] # Assuming this is the IfcLocalPlacement for the opening

                opening_extrusion = self.ifc_model.opening_extrusion(
                    opening_closed_profile, float(opening_height), start_point, end_point,
                    float(window_sill_height), float(offset_from_start)
                )
                opening_representation = self.ifc_model.opening_representation(opening_extrusion)
                opening_product_definition = self.ifc_model.product_definition_shape_opening(opening_representation)
                
                ifc_opening_element = self.ifc_model.create_wall_opening(ifc_opening_local_placement, opening_product_definition)
                self.ifc_model.create_rel_voids_element(ifc_wall, ifc_opening_element)

                # Create Window or Door filling the opening
                filling_element_thickness = 0.05 # Example thickness for window/door frame/panel
                if opening_type == "window":
                    window_closed_profile = self.ifc_model.opening_closed_profile_def(float(opening_width), filling_element_thickness)
                    window_extrusion = self.ifc_model.opening_extrusion(
                        window_closed_profile, float(opening_height), start_point, end_point,
                        float(window_sill_height), float(offset_from_start)
                    )
                    window_representation = self.ifc_model.opening_representation(window_extrusion)
                    window_product_definition = self.ifc_model.product_definition_shape_opening(window_representation)
                    
                    ifc_window = self.ifc_model.create_window(ifc_opening_local_placement, window_product_definition, opening_id_str)
                    window_type_obj, _ = self.ifc_model.create_window_type() # Assuming it returns type and representation
                    self.ifc_model.create_rel_defines_by_type(ifc_window, window_type_obj)
                    self.ifc_model.create_rel_fills_element(ifc_opening_element, ifc_window)
                    self.ifc_model.assign_product_to_storey(ifc_window, ifc_storey_for_wall)
                    self.ifc_model.assign_material(ifc_window, window_material)
                elif opening_type == "door":
                    door_closed_profile = self.ifc_model.opening_closed_profile_def(float(opening_width), filling_element_thickness)
                    door_extrusion = self.ifc_model.opening_extrusion(
                        door_closed_profile, float(opening_height), start_point, end_point,
                        float(window_sill_height), float(offset_from_start) # Doors usually start from z=0 relative to floor
                    )
                    door_representation = self.ifc_model.opening_representation(door_extrusion)
                    door_product_definition = self.ifc_model.product_definition_shape_opening(door_representation)
                    
                    ifc_door = self.ifc_model.create_door(ifc_opening_local_placement, door_product_definition, opening_id_str)
                    # door_type_obj, _ = self.ifc_model.create_door_type() # If you have door types
                    # self.ifc_model.create_rel_defines_by_type(ifc_door, door_type_obj)
                    self.ifc_model.create_rel_fills_element(ifc_opening_element, ifc_door)
                    self.ifc_model.assign_product_to_storey(ifc_door, ifc_storey_for_wall)
                    self.ifc_model.assign_material(ifc_door, door_material)
        self._log(f"Added {len(self.walls)} walls and {len(self.all_openings)} openings to IFC.")

        # Write IFC File
        self.ifc_model.write()
        self._log(f'IFC model saved to {self.ifc_output_file}.')

    def _save_point_mapping(self):
        """
        Save the mapping between point cloud indices and IFC elements.
        This is useful for visualization and validation.
        """
        mapping = {
            'slabs': {},
            'walls': {},
            'openings': {}
        }
        
        # Add mapping for slabs
        for idx, slab in enumerate(self.slabs):
            slab_id = f"slab_{idx+1}"
            if 'point_indices' in slab:
                mapping['slabs'][slab_id] = {
                    'points': slab['point_indices'].tolist(),
                    'height': slab['slab_bottom_z_coord'],
                    'thickness': slab['thickness']
                }

        # Add mapping for walls
        for wall in self.walls:
            wall_id = f"wall_{wall['wall_id']}"
            if 'point_indices' in wall:
                mapping['walls'][wall_id] = {
                    'points': wall['point_indices'].tolist(),
                    'storey': wall['storey'],
                    'thickness': wall['thickness'],
                    'label': wall['label']
                }

        # Add mapping for openings
        for idx, opening in enumerate(self.all_openings):
            opening_id = f"{opening['opening_type']}_{idx+1}"
            if 'point_indices' in opening:
                mapping['openings'][opening_id] = {
                    'points': opening['point_indices'].tolist(),
                    'wall_id': opening['opening_wall_id'],
                    'type': opening['opening_type']
                }

        try:
            with open(self.point_mapping_file, 'w') as f:
                json.dump(mapping, f, indent=2)
            self._log(f"Point mapping saved to {self.point_mapping_file}")
        except Exception as e:
            self._log(f"Error saving point mapping: {e}", level="error")

    def process(self):
        """
        Executes the full point cloud to IFC conversion process.
        Returns None on success, raises exception on failure.
        """
        try:
            self._log("Processing started.")

            # 1. Load and prepare point cloud
            self._log("Loading and preparing point cloud...")
            self._load_and_prepare_point_cloud()
            if self.points_xyz.size == 0:
                raise ValueError("Point cloud is empty after loading")
            self._log(f"Point cloud loaded with {self.points_xyz.shape[0]} points")

            # 2. Identify slabs (floors and ceilings)
            self._log("Identifying slabs...")
            self._identify_slabs()
            if not self.slabs:
                raise ValueError("No slabs identified in point cloud")
            self._log(f"{len(self.slabs)} slabs identified")

            # 3. Identify walls and openings
            self._log("Identifying walls and openings...")
            self._identify_walls_and_openings()
            self._log(f"{len(self.walls)} walls and {len(self.all_openings)} openings identified")

            # 4. Identify zones (rooms/spaces)
            self._log("Identifying zones...")
            self._identify_zones()
            num_zones = sum(len(zones_dict) for zones_dict in self.zones)
            self._log(f"{num_zones} zones identified across all storeys")

            # 5. Generate IFC model
            self._log("Generating IFC model...")
            self._generate_ifc_model()
            self._log(f"IFC model generated at {self.ifc_output_file}")

            # 6. Save point-to-element mapping
            self._log("Saving point-to-element mapping...")
            self._save_point_mapping()

            self._log("Processing completed successfully")

        except Exception as e:
            self._log(f"Error during processing: {str(e)}", level="error")
            logger.exception(f"Job {self.job_id}: Full traceback for error during processing")
            raise

# === Remove the old script execution logic below this line ===
# All the code that was previously global (reading files, calling functions)
# should now be part of the CloudToBimProcessor class methods or
# handled by the job_processor.py which will instantiate and run this class.

# Example of how job_processor.py might use this:
# from .cloud2entities import CloudToBimProcessor
#
# def process_conversion_job(job_id: str, config_data: dict, input_dir: str, output_dir: str):
#     processor = CloudToBimProcessor(job_id, config_data, input_dir, output_dir)
#     success, result_or_error = processor.process()
#     if success:
#         # Update job status to completed, store result_or_error (IFC path)
#         pass
#     else:
#         # Update job status to failed, store result_or_error (error message)
#         pass